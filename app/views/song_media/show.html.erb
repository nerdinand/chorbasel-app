<% content_for :title, @song_medium.song.title %>

<% if (recording = @song_medium.song.song_media.recording.first) %>
  <%= audio_tag url_for(recording.file), controls: true, preload: 'none', id: 'recording-player', style: 'width: 100%' %>
<% end %>

<style>
  .playing {
    fill: crimson;
  }
</style>

<div id="notation" class="relative left-1/2 w-dvw max-w-none -translate-x-1/2"></div>

<script>
  function buildMeasureList() {
    i = 1
    lastMeasureId = null
    measures = []
    while(true) {
      elements = toolkit.getElementsAtTime(i)
      currentMeasureId = elements.measure

      if (currentMeasureId === undefined) {
        break
      }

      if (currentMeasureId != lastMeasureId) {
        lastMeasureId = currentMeasureId
        measures.push([currentMeasureId, elements.page])
      }
      i += 500
    }

    document.measureList = measures
  }

  document.secondsToMeasureNumberMap = [
    [0.0, 1], // first measure
    [2.733038, 2],
    [4.919296, 1],
    [7.248955, 2],
    [9.206111, 3],
    [51.912, 22],
    [54.663843, 3],
    [99.730816, 23],
    [118.077809, 31],
    [172.431, 54]  // last measure
  ]

  function getMeasure(recordingTime) {
    biggerIndex = document.secondsToMeasureNumberMap.findIndex((e) => e[0] > recordingTime)

    if (biggerIndex == -1) {
      return Math.max(...document.secondsToMeasureNumberMap.map(e => e[1]))
    }

    smallerIndex = biggerIndex - 1

    biggerMeasureNumber = document.secondsToMeasureNumberMap[biggerIndex][1]
    smallerMeasureNumber = document.secondsToMeasureNumberMap[smallerIndex][1]

    if (biggerMeasureNumber <= smallerMeasureNumber) {
      console.log("detected repetition!")
      return
    }

    biggerTime = document.secondsToMeasureNumberMap[biggerIndex][0]
    smallerTime = document.secondsToMeasureNumberMap[smallerIndex][0]

    sectionLength = biggerTime - smallerTime
    measuresLength = biggerMeasureNumber - smallerMeasureNumber 
    return smallerMeasureNumber + parseInt(((recordingTime - smallerTime) * measuresLength) / sectionLength)
  }

  function showMeasure(measure) {
    let playingMeasures = document.querySelectorAll('.playing');
    for (let playingMeasure of playingMeasures) playingMeasure.classList.remove("playing");
    measureListEntry = document.measureList[measure - 1]
    playingMeasure = document.getElementById(measureListEntry[0])

    if (playingMeasure === null) {
      document.getElementById("notation").innerHTML = toolkit.renderToSVG(measureListEntry[1]);
      playingMeasure = document.getElementById(measureListEntry[0])
    }

    playingMeasure.classList.add("playing")
  }
  
  var delayInMilliseconds = 200;

  function updatePlayingMeasure() {
    showMeasure(getMeasure(document.getElementById("recording-player").currentTime))
    setTimeout(updatePlayingMeasure, delayInMilliseconds)
  }

  document.addEventListener("DOMContentLoaded", (event) => {
    verovio.module.onRuntimeInitialized = () => {
      toolkit = new verovio.toolkit()
      toolkit.setOptions({
        pageWidth: document.body.clientWidth,
        pageHeight: 100,
        scale: 50,
        svgViewBox: true,
        scaleToPageSize: true,
        header: 'none',
        footer: 'none',
        lyricSize: 3,
        lyricWordSpace: 2,
        adjustPageHeight: true,
        adjustPageWidth: true,
      })

      let currentPage = 1;

      const playMIDIHandler = function () {
        // Get the MIDI file from the Verovio toolkit
        let base64midi = toolkit.renderToMIDI();
        // Add the data URL prefixes describing the content
        let midiString = 'data:audio/midi;base64,' + base64midi;
        // Pass it to play to MIDIjs
        MIDIjs.play(midiString);
      }

      const stopMIDIHandler = function () {
        MIDIjs.stop();
      }

      const midiHightlightingHandler = function (event) {
        // Remove the attribute 'playing' of all notes previously playing
        let playingNotes = document.querySelectorAll('g.note.playing');
        for (let playingNote of playingNotes) playingNote.classList.remove("playing");

        // Get elements at a time in milliseconds (time from the player is in seconds)
        let currentElements = toolkit.getElementsAtTime(event.time * 1000);

        if (currentElements.page == 0) return;

        if (currentElements.page != currentPage) {
          currentPage = currentElements.page;
          document.getElementById("notation").innerHTML = toolkit.renderToSVG(currentPage);
        }

        // Get all notes playing and set the class
        for (note of currentElements.notes) {
          let noteElement = document.getElementById(note);
          if (noteElement) noteElement.classList.add("playing");
        }
      }

      const seekedHandler = function (event) {
        showMeasure(getMeasure(event.target.currentTime))
      }

      document.getElementById("recording-player").addEventListener("seeked", seekedHandler)
      document.getElementById("recording-player").addEventListener("pause", seekedHandler)

      MIDIjs.player_callback = midiHightlightingHandler;

      fetch("<%= url_for(@song_medium.file) %>")
      .then( (response) => response.text() )
      .then( (meiXML) => {
        let svg = toolkit.renderData(meiXML, {});
        document.getElementById("notation").innerHTML = svg;
      })
      .then(buildMeasureList)
      .then(() => {
        setTimeout(updatePlayingMeasure, delayInMilliseconds)
      })
      // .then( response => response.arrayBuffer() )
      // .then( data => {
      //   let meiXML = toolkit.loadZipDataBuffer(data)
      //   let svg = toolkit.renderData(meiXML, {})
      //   document.getElementById("notation").innerHTML = svg
      // })
    }
  });
</script>
