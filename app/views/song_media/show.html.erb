<% content_for :title, @song_medium.song.title %>

<% if (recording = @song_medium.song.song_media.recording.first) %>
  <%= audio_tag url_for(recording.file), controls: true, preload: 'none', id: 'recording-player', style: 'width: 100%' %>
<% end %>

<style>
  .playing {
    fill: crimson;
  }
</style>

<div id="notation" class="relative left-1/2 w-dvw max-w-none -translate-x-1/2"></div>

<script>
  function buildMeasureList() {
    i = 1
    lastMeasureId = null
    measures = []
    while(true) {
      elements = toolkit.getElementsAtTime(i)
      currentMeasureId = elements.measure

      if (currentMeasureId === undefined) {
        break
      }

      if (currentMeasureId != lastMeasureId) {
        lastMeasureId = currentMeasureId
        measures.push([currentMeasureId, elements.page])
      }
      i += 500
    }

    document.measureList = measures
  }

  document.secondsToMeasureNumberMap = [
    // bass intro
    [0.0,         1], // first measure
    [2.535,       2],
    // repetition
    [4.737,       1],
    [9.164,       3],
    // SAT joins in (first verse)
    [51.912,      22],
    // repetition: second verse
    [54.478,      3],
    [108.899,     27],
    // bridge
    [117.924,     31],
    [136.081,     39],
    [171.507,     55],  // last measure
  ]

  function getMeasure(recordingTime) {
    biggerIndex = document.secondsToMeasureNumberMap.findIndex((e) => e[0] > recordingTime)

    if (biggerIndex == -1) {
      return Math.max(...document.secondsToMeasureNumberMap.map(e => e[1]))
    }

    smallerIndex = biggerIndex - 1

    nextMeasureNumber = document.secondsToMeasureNumberMap[biggerIndex][1]
    previousMeasureNumber = document.secondsToMeasureNumberMap[smallerIndex][1]

    if (nextMeasureNumber - previousMeasureNumber <= 1 || nextMeasureNumber <= previousMeasureNumber) {
      // Either next measure is just one bigger or the same as the current, 
      // or we going to a repetition in the next measure: Either way, no interpolation needed!
      return previousMeasureNumber
    }

    biggerTime = document.secondsToMeasureNumberMap[biggerIndex][0]
    smallerTime = document.secondsToMeasureNumberMap[smallerIndex][0]

    sectionTimeLength = biggerTime - smallerTime
    sectionMeasuresLength = nextMeasureNumber - previousMeasureNumber
    currentTimeInSection = recordingTime - smallerTime
    currentMeasureInSection = parseInt((currentTimeInSection * sectionMeasuresLength) / sectionTimeLength)
    return previousMeasureNumber + currentMeasureInSection
  }

  function showMeasure(measure) {
    let playingMeasures = document.querySelectorAll('.playing');
    for (let playingMeasure of playingMeasures) playingMeasure.classList.remove("playing");
    measureListEntry = document.measureList[measure - 1]
    playingMeasure = document.getElementById(measureListEntry[0])

    if (playingMeasure === null) {
      document.getElementById("notation").innerHTML = toolkit.renderToSVG(measureListEntry[1]);
      playingMeasure = document.getElementById(measureListEntry[0])
    }

    playingMeasure.classList.add("playing")
  }
  
  var delayInMilliseconds = 200;

  function updatePlayingMeasure() {
    showMeasure(getMeasure(document.getElementById("recording-player").currentTime))
    setTimeout(updatePlayingMeasure, delayInMilliseconds)
  }

  document.addEventListener("DOMContentLoaded", (event) => {
    verovio.module.onRuntimeInitialized = () => {
      toolkit = new verovio.toolkit()
      toolkit.setOptions({
        pageWidth: document.body.clientWidth,
        pageHeight: 100,
        scale: 50,
        svgViewBox: true,
        scaleToPageSize: true,
        header: 'none',
        footer: 'none',
        lyricSize: 3,
        lyricWordSpace: 2,
        adjustPageHeight: true,
        adjustPageWidth: true,
      })

      document.getElementById("notation").innerHTML = toolkit.renderToSVG(1);

      const seekedHandler = function (event) {
        time = event.target.currentTime
        measure = getMeasure(time)
        console.log(time, measure)
        showMeasure(measure)
      }

      document.getElementById("recording-player").addEventListener("seeked", seekedHandler)
      document.getElementById("recording-player").addEventListener("pause", seekedHandler)

      fetch("<%= url_for(@song_medium.file) %>")
      .then( (response) => response.text() )
      .then( (meiXML) => {
        let svg = toolkit.renderData(meiXML, {});
        document.getElementById("notation").innerHTML = svg;
      })
      .then(buildMeasureList)
      .then(() => {
        setTimeout(updatePlayingMeasure, delayInMilliseconds)
      })
      // .then( response => response.arrayBuffer() )
      // .then( data => {
      //   let meiXML = toolkit.loadZipDataBuffer(data)
      //   let svg = toolkit.renderData(meiXML, {})
      //   document.getElementById("notation").innerHTML = svg
      // })
    }
  });
</script>
